Вступление
Что такое параллельные вычисления
Процессы, потоки, корутины и горутины
Как планировщик Go управляет горутинами
Синхронизация горутин
Буферизованные каналы
Закрытие канала
Итерирование по каналам
Конструкция select
Аксиомы каналов
Конкурентный доступ и состояние гонки
Примитивы синхронизации
Mutex
Mutex. Техника безопасности
RWMutex
Атомики (атомарные счётчики)
sync.Map
WaitGroup
Достойны упоминания: sync.Pool и sync.Cond
Финал

## Что такое параллельные вычисления
Параллелизм — это свойство систем, при котором несколько вычислений выполняются одновременно и могут взаимодействовать друг с другом.

- Параллелизм работает на физическом уровне
- Конкурентность работает на логическом

Процессор с одним ядром может исполнять только одну программу или процесс.

Несколько ядер = несколько процессов.

Внутри процесса задачи распределяются эффективно, так что когда один процесс ожидает какое-то время ответа (простаивает), начинает исполняться другая задача. Этим и занимается планировщик.

## Процессы, потоки, корутины и горутины
- Конкурентность — один повар переключается между готовкой разных блюд.
- Параллелизм — несколько поваров одновременно готовят блюда, каждый своё.

Процессы могут создавать потоки, при этом всегда есть один главный поток.

Горутина — инструмент для работы с конкурентными вычислениями.
- Гораздо легковеснее потока, поэтому их можно создавать миллионами и не страдать от этого.
- Контролируются на уровне программы, а не операционной системы.
- На одном потоке может исполняться несколько горутин.

Чтобы асинхронно вызвать функцию, воспользуемся ключивим словом go.
Пример:

```go
func foo() {
    fmt.Println("Hello, world!")
}

// Функцию foo можно вызвать синхронно:
foo() // => Hello, world!

// Или асинхронно:
go foo()

```

## Как планировщик Go управляет горутинами
Есть два подхода:
- Кооперативный
- Вытесняющий

Кооперативная многозадачность — контекст переключается в момент, когда текущая активная задача явно сообщает, что она готова отдать ресурс другой задаче.

Вытесняющая многозадачность — некий компонент управляет переключением контекста и может принудительно ставить одни задачи на паузу и продолжать выполнение других.

В Go реализован **смешанный** подход. Планировщик сам определяет, когда и как переключать горутины.

Разработчик может явно передать управление другим горутинам с помощью:
```go
runtime.Gosched()
```

## Синхронизация горутин
Для синхронизации горутин используются **каналы**:

```go
// Объявление канала
ch := make(chan int)

// Запись в канал
ch <- 1

// Чтение из канала
v := <-ch

```
Дополнительные примеры, чтобы детальнее разобраться:
- Пример из <a href="https://go.dev/tour/concurrency/1" target="_blank">Go Tour 1</a>
- Пример из <a href="https://go.dev/tour/concurrency/2" target="_blank">Go Tour 2</a>

## Буферизованные каналы
Каналы могут иметь емкость. Это значит, что запись в канал будет заблокирована только после записи `n` элементов в канал. Чтение будет заблокировано, если канал пуст.

Пример буферизованного канала:
```go
// Емкость канала — 2
ch := make(chan int, 2)
```

## Закрытие канала
Канал можно закрыть. Если попытаться записать данные в закрытый канал, произойдет паника.

Пример:
```go
close(ch)
v, ok := <-ch // ok == false, если канал закрыт
```

## Итерирование по каналам
По каналам можно итерироваться:
```go
for v := range ch {
    fmt.Println(v)
}
```
Цикл завершится, когда канал закроется.

## Конструкция select

Select позволяет ждать значения из нескольких каналов.

Пример:

```go
func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c <- x: // Отправляем текущее значение x в канал c
            x, y = y, x+y // Обновляем значения x и y
        case <-quit: // Если получено сообщение из канала quit
            fmt.Println("quit")
            return // Завершаем выполнение функции
        }
    }
}

func main() {
    c := make(chan int)  // Создаем канал для передачи чисел Фибоначчи
    quit := make(chan int) // Создаем канал для завершения работы

    go func() { // Запускаем анонимную горутину
        for i := 0; i < 10; i++ {
            fmt.Println(<-c) // Получаем значение из канала c и выводим его
        }
        quit <- 0 // Отправляем сообщение в канал quit (завершение работы)
    }()

    fibonacci(c, quit) // Запускаем функцию fibonacci
}

```

Однако логика от switch/case отличается от select:
1. Сначала будет срабатывать тот кейс, для которого запись в ожидаемый канал произойдет первой.
2. default срабатывает если в момент вызова select ни один из каналов не готов для чтения.
3. В случае, если несколько каналов доступны для чтения, будет выбран случайный кейс.

## Аксиомы каналов

- Запись в неинициализированный канал блокирует поток навсегда;
- Чтение из неинициализированного канала блокирует поток навсегда;
- Запись в закрытый канал вызывает панику;
- Чтение из закрытого канала даёт нулевое значение мгновенно.

## Конкурентный доступ и состояние гонки

Race detector - компилятор гонок. Для того чтобы запустить программу с режимом отслеживания гонок, необходимо добавить флаг --race к запуску программы. 

- Race detector сообщает о гонках, только тогда, когда она действительно есть. Но иногда он не находят гонку, тоже нужно быть к этому готовым
- Добавляет заметные накладные расходы, тем самым замедляет выполнение программы

## Примитивы синхронизации
Для решения проблем с гонками, придуманы примитивы синхронизации:
- Mutex
- RWMutex
- Атомики
- sync.Map
- WaitGroup
А так же достоынй упоминания:
- sync.Pool
- sync.Cond

## Mutex
Mutex - это объект, который может находиться в двух состояниях, в разблокированном и забокированном.
Алгоритм работы с Mutex обычно такой:

1. В потоке A вызывается метод M, модифицирующий данные, доступ к которым необходимо синхронизировать;
2. Внутри M блокируется мьютекс;
3. Выполняется остальная часть функции;
4. Мьютекс разблокируется.

Пример кода:
```go
package main

import (
	"log"
	"math/rand"
	"sync"
	"time"
)

// Объявляем ошибку недостатка средств
var errInsufficientFunds = errors.New("недостаточно средств")

type playerWallet struct {
    coins int64
    mu    sync.Mutex   // Мьютекс для предотвращения гонок данных при доступе к полю coins
}

func (w *playerWallet) spendCoins(amount int64) error {
    w.mu.Lock()              // Блокируем мьютекс, чтобы другие потоки не могли изменять coins одновременно.
    defer w.mu.Unlock()      // Откладываем разблокировку мьютекса до завершения функции

    // Проверяем, достаточно ли монет для списания.
    if w.coins-amount < 0 {
		log.Printf("spent %d coin(s), balance: %d", amount, w.coins)
		return errInsufficientFunds // Если недостаточно средств, возвращаем ошибку
    }

    // Списываем указанное количество монет
    w.coins -= amount
    // Логируем информацию о списании монет и текущем балансе
    log.Printf("spent %d coin(s), balance: %d", amount, w.coins)
    return nil // Возвращаем nil, так как операция прошла успешно
}

func payForUnitsAndBuildings(w *playerWallet) {
    // Вызываем метод spendCoins и обрабатываем возможную ошибку
    if err := w.spendCoins(3); err != nil {
        log.Println(err) // Логируем ошибку, если недостаточно средств
    }
}

func buyAnotherUnitInShop(w *playerWallet) {
    // Вызываем метод spendCoins и обрабатываем возможную ошибку.
    if err := w.spendCoins(4); err != nil {
        log.Println(err)
    }
}

func main() {
    var (
        wg sync.WaitGroup // Создаем WaitGroup для ожидания завершения горутин
        wallet = &playerWallet{coins: 5} // Инициализируем кошелек игрока с 5 монетами
    )

    rand.Seed(time.Now().Unix()) // Инициализируем генератор случайных чисел

    wg.Add(1) // Увеличиваем счетчик WaitGroup на 1
    go func() {
        defer wg.Done() // Уменьшаем счетчик на 1 при завершении горутины
        time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) // Ждем случайное время
        payForUnitsAndBuildings(wallet) // Вызываем функцию для покупки единиц и зданий
    }()

    wg.Add(1) // Увеличиваем счетчик WaitGroup на 1
    go func() {
        defer wg.Done() // Уменьшаем счетчик на 1 при завершении горутины
        time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) // Ждем случайное время
        buyAnotherUnitInShop(wallet) // Вызываем функцию для покупки единицы в магазине
    }()

    wg.Wait() // Ожидаем завершения всех горутин
}


```

## Mutex. Техника безопасности

Не делай так:

```go
// Никогда не встривайте Mutex в структуру (struct)
type MyAwesomeStruct struct {
    sync.Mutex
}

// Никогда не храните ссылку на Mutex в поле структуры
type MyAwesomeStruct2 struct { 
    mu *sync.Mutex
}

// Методы должны иметь ссылочный ресивер
// Внутри функции есть mu.Lock() и mu.Unlock()
func (m MyAwesomeStruct3) ...
```

## RWMutex
Когда приложение имеет высокую частоту операций: чтение и записи в какой-то области памяти использование обычного Mutex заметно снижает производительность.
Помочь нам с этим может sync.RWMutex. Это все тот же Mutex, только он позволяет получать эксклюзивные блокировки отдельно на чтение и отдельно на запись

Пример:
```go
type playerWallet struct {
    coins int64
    mu    sync.RWMutex
}

func (w *playerWallet) getCoins() int64 {
    w.mu.RLock()
    coins := w.coins
    w.mu.RUnlock()
    return coins
}

func (w *playerWallet) spendCoins(amount int64) error {
    w.mu.Lock()
    defer w.mu.Unlock()

    if w.coins-amount < 0 {
        return ErrInsufficientFunds
    }

    w.coins -= amount
    log.Printf("spent %d coin(s), balance: %d", amount, w.coins)
    return nil
}

```

**Используйте RWMutex, когда нужно управлять доступом к более сложным данным и когда важно разделять операции чтения и записи.**

## Атомики (атомарные счётчики)

Атомики интересны тем, что они позволяют конкурентно читать и писать данные без блокировок.
Пример:

```go
func (w *playerWallet) spendCoins(amount int64) error {
    if atomic.LoadInt64(&w.coins)-amount < 0 {
        return ErrInsufficientFunds
    }

    atomic.AddInt64(&w.coins, -amount)
    log.Printf("spent %d coin(s), balance: %d", amount, w.coins)
    return nil
}

```
**Используйте атомарные операции для простых, часто изменяемых переменных, где важна высокая производительность и минимальные накладные расходы.**
Но атомарные операции является низкоуровнемым инструментом и не рекомендуется использовать без четкой надобности (можно легко сломать программу).

## sync.Map
sync.Map — это специальный тип карты (map) в языке Go, который предназначен для безопасного параллельного доступа из нескольких горутин (goroutines). 
Пример:

```go
var sm sync.Map

sm.Store("foo", int64(42))

fortyTwoAny, ok := sm.Load("foo")
if !ok {
    return errors.New("key '42' does not exist")
}

fortyTwo, ok := fortyTwoAny.(int64)
if !ok {
    return errors.New("42 is not int64")
}

fmt.Println(fortyTwo)

sm.Delete("foo")

```

**В общем, sync.Map полезен, когда нужно хранить данные, к которым одновременно обращаются несколько горутин, и при этом избежать проблем с конкурентным доступом.**

## WaitGroup
WaitGroup ждет пока набор горутин завершит работу. Главная горутина должна содежать вызов метода Add - wg.Add(1).
Метод wg.Done() сообщает что горутина завершила работу и счетчик можно понизить
Метод wg.Wait() используется чтобы заблокировать текущую горутину, пока внутрений счетчик WaitGroup не достигнет нуля за счет вызовов метода Done.

**WaitGroup полезен, когда необходимо выполнить несколько долгих и независимых операций, но результат каждой из этих операций вам важен.**

## Достойны упоминания: sync.Pool и sync.Cond

sync.Pool — это структура, предназначенная для управления временными объектами и их переиспользования.
- Цель: Снижает нагрузку на сборщик мусора, позволяя избежать частого создания и уничтожения объектов.
- Использование: Подходит для объектов, которые используются временно и могут быть переработаны, например, буферов или временных структур данных.


sync.Cond — это условная переменная, которая позволяет горутинам ждать определенного условия.
- Цель: Используется для синхронизации между горутинами, позволяя одной горутине ждать, пока другая не изменит состояние.
- Использование: Полезно в сценариях, где требуется уведомление о наступлении события, например, в очередях или при производстве/потреблении данных.

Те же самые задачи что и решают данные методы, можно решить с помощью каналов, но хотя бы знать что эти методы есть - нужно.
